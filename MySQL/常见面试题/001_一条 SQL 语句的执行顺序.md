1、SQL 语句中常见关键词的优先级  
>1.from  
> 
>2.join, left join, right join -- 等等  
>
>3.on  
>
>4.where  -- where 条件中不可以使用别名  
>
>5.group by -- 从这里开始，可以使用 select 中的别名，后面的子句都可以使用  
>
>6.avg, max, sum -- 等函数  
>
>7.having -- 必须和 group by 联合使用  
>
>8.select -- select 虽然在 sql 语句的一开始位置，但是执行顺序却比较靠后  
>
>9.distinct -- 当查询出数据之后才可以进行去重排序等操作  
>
>10.order by  
>
>11.limit  

从这个顺序中我们不难发现，所有的查询语句都是从 from 开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，**这个虚拟表将作为下一个执行步骤的输入**。

问题：为什么 where 中不可以使用别名而 having 中可以使用别名？
>因为 where 的优先级较高，在别名还没有生效的时候，就已经执行了，也就是说 where 子句中是拿不到别名的。而 having 子句的优先级比较靠后，在别名生效之后才执行，也就是说 having 子句是可以拿到生效的别名的。  

2、SQL 语句的正式执行步骤  

（1）第一步 执行 from 语句  
先根据 from 定位到两张表，然后对 from 子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）；  

（2）第二步 执行 on 过滤  
接下来便是应用 on 筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足 on 逻辑表达式的行，生成虚拟表 vt2；  

（3）第三步 添加外部行  
如果指定了 outer join（相对于 cross join 或(inner join)，保留表（preserved table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中 `未找到匹配的行将作为外部行` 添加到 VT2 并生成 VT3；  

（4）第四步 多表 join  
如果 from 子句中的表数目多余两个表，那么就将 vt3 和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复 1-3 的步骤，最终得到一个新的虚拟表 vt3；  

（5）第五步 执行 where 过滤  
应用 where 筛选器，对上一步生产的虚拟表引用 where 筛选器，生成虚拟表 vt4，在这有个比较重要的细节不得不说一下，对于包含 outer join 子句的查询，就有一个让人感到困惑的问题，到底在 on 筛选器还是用 where 筛选器指定逻辑表达式呢？on 和 where 的最大区别在于，如果在 on 应用逻辑表达式那么在第三步 outer join 中还可以把移除的行再次添加回来，而 where 的移除的最终的。举个简单的例子，有一个学生表 (班级, 姓名) 和一个成绩表 (姓名，成绩)，我现在需要返回一个某班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在 on 子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在 vt2 中，因为他们被 on 的逻辑表达式过滤掉了，但是我们用 left outer join 就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是某班级的所有学生，如果在 on 中应用学生.班级='x'的话，left outer join 会把 x 班级的所有学生记录找回（感谢网友康钦谋__康钦苗的指正），所以只能在 where 筛选器中应用学生.班级='x' 因为它的过滤是最终的。也就是说在 内连接 inner join 的时候，on 和 where 的作用是一样的，但是在外连接的时候，on 和 where 的作用就是不一样的，on 可以保留不匹配的行，也就是添加外部行。  

（5）第六步 执行 group by 分组  
group by 子句将中的唯一的值组合成为一组，得到虚拟表 vt5。如果应用了 group by，那么后面的所有步骤都只能得到的 vt5 的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行，这一点请牢记；  

（7）第七步  
应用 cube 或者 rollup 选项，为 vt5 生成超组，生成 vt6；  

（8）第八步 执行 having 过滤器  
应用 having 筛选器，生成 vt7。having 筛选器是第一个也是为唯一一个应用到已分组数据的筛选器；  

（9）第九步 执行 select 子句  
处理 select 子句，将 vt7 中的在 select 中出现的列筛选出来，生成 vt8；  

（10）第十步 执行 distinct 子句  
应用 distinct 子句，vt8 中移除相同的行，生成 vt9。事实上如果应用了 group by 子句那么 distinct 是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的；

（11）第十一步 执行 order by 子句  
应用 order by 子句。按照 order_by_condition 排序 vt9，此时返回的一个游标，而不是虚拟表。sql 是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用 order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定 order by，最后，在这一步中是第一个也是唯一一个可以使用 select 列表中别名的步骤。

（12）第十二步 执行 limit 子句  
应用 top 选项，此时才返回结果给请求者即用户  
